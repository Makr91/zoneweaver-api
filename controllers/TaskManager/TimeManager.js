import yj from 'yieldable-json';
import { executeCommand } from '../../lib/CommandManager.js';
import { setRebootRequired } from '../../lib/RebootManager.js';
import { log } from '../../lib/Logger.js';

/**
 * Time Manager for Time Synchronization Operations
 * Handles time sync configuration, force sync, timezone setting, and system switching
 */

/**
 * Helper function to extract servers from config (for migration)
 * @param {string} configContent - Configuration file content
 * @param {string} systemType - System type (ntp, chrony, ntpsec)
 * @returns {Array<string>} Array of server addresses
 */
export const extractServersFromConfig = (configContent, systemType) => {
  const servers = [];
  const lines = configContent.split('\n');

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip commented lines
    if (
      trimmed.startsWith('#') ||
      trimmed.startsWith('!') ||
      trimmed.startsWith('%') ||
      trimmed.startsWith(';')
    ) {
      continue;
    }

    // Handle both 'server' and 'pool' directives
    if (
      (trimmed.startsWith('server ') || trimmed.startsWith('pool ')) &&
      !trimmed.includes('127.127.1.0') &&
      !trimmed.includes('127.0.0.1')
    ) {
      const parts = trimmed.split(/\s+/);
      if (parts.length >= 2) {
        servers.push(parts[1]);
      }
    }
  }

  // Return extracted servers or appropriate defaults based on system type
  if (servers.length > 0) {
    return servers;
  }

  // System-specific defaults
  switch (systemType) {
    case 'chrony':
      return ['0.omnios.pool.ntp.org'];
    case 'ntp':
    case 'ntpsec':
    default:
      return ['0.pool.ntp.org', '1.pool.ntp.org', '2.pool.ntp.org', '3.pool.ntp.org'];
  }
};

/**
 * Helper function to generate config for target system
 * @param {string} targetSystem - Target system type (ntp, chrony, ntpsec)
 * @param {Array<string>} servers - Array of server addresses
 * @returns {string} Generated configuration content
 */
export const generateConfigForSystem = (targetSystem, servers) => {
  let baseConfig = '';

  switch (targetSystem) {
    case 'ntp':
      baseConfig = `# Generated by Zoneweaver API - System Switch
# NTP configuration for OmniOS

driftfile /var/ntp/ntp.drift

# Access restrictions
restrict default ignore
restrict -6 default ignore
restrict 127.0.0.1
restrict -6 ::1

# Time servers
${servers.map(server => `server ${server} iburst`).join('\n')}

# Allow updates from configured servers
${servers.map(server => `restrict ${server} nomodify noquery notrap`).join('\n')}
`;
      break;
    case 'chrony':
      baseConfig = `# Generated by Zoneweaver API - System Switch
# Chrony configuration for OmniOS

# Time servers
${servers.map(server => `server ${server} iburst`).join('\n')}

# Drift file location
driftfile /var/lib/chrony/drift

# Allow chronyd to make gradual corrections
makestep 1.0 3

# Enable RTC sync
rtcsync

# Log measurements
logdir /var/log/chrony
log measurements statistics tracking
`;
      break;
    case 'ntpsec':
      baseConfig = `# Generated by Zoneweaver API - System Switch
# NTPsec configuration for OmniOS

driftfile /var/lib/ntp/ntp.drift

# Access restrictions
restrict default kod limited nomodify nopeer noquery notrap
restrict -6 default kod limited nomodify nopeer noquery notrap
restrict 127.0.0.1
restrict -6 ::1

# Time servers
${servers.map(server => `server ${server} iburst`).join('\n')}

# Allow updates from configured servers
${servers.map(server => `restrict ${server} nomodify noquery notrap`).join('\n')}
`;
      break;
    default:
      throw new Error(`Unknown target system: ${targetSystem}`);
  }

  return baseConfig;
};

/**
 * Helper function to verify service status
 * @param {string} serviceName - Service name to verify
 * @param {number} maxAttempts - Maximum verification attempts
 * @returns {Promise<boolean>} Service online status
 */
const verifyServiceStatus = (serviceName, maxAttempts = 10) =>
  new Promise(resolve => {
    let attempt = 0;

    const checkService = async () => {
      if (attempt >= maxAttempts) {
        resolve(false);
        return;
      }

      if (attempt > 0) {
        await new Promise(resolveDelay => {
          setTimeout(() => resolveDelay(), 2000);
        });
      }

      const statusResult = await executeCommand(`svcs network/${serviceName}`);

      if (statusResult.success && statusResult.output.includes('online')) {
        log.task.info('Service is online', { service: serviceName });
        resolve(true);
        return;
      }

      attempt++;
      log.task.debug('Waiting for service to come online', {
        service: serviceName,
        attempt,
        max_attempts: maxAttempts,
      });

      checkService();
    };

    checkService();
  });

/**
 * Execute time sync configuration update task
 * @param {string} metadataJson - Task metadata as JSON string
 * @returns {Promise<{success: boolean, message?: string, error?: string}>}
 */
export const executeUpdateTimeSyncConfigTask = async metadataJson => {
  log.task.debug('Time sync config update task starting');

  try {
    const metadata = await new Promise((resolve, reject) => {
      yj.parseAsync(metadataJson, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
    const { service, config_content, backup_existing, restart_service } = metadata;

    log.task.debug('Time sync config update parameters', {
      service,
      backup_existing,
      restart_service,
      config_content_length: config_content ? config_content.length : 0,
    });

    // Determine config file path based on service
    let configFile;
    if (service === 'ntp') {
      configFile = '/etc/inet/ntp.conf';
    } else if (service === 'chrony') {
      configFile = '/etc/inet/chrony.conf';
    } else {
      return { success: false, error: `Unknown time sync service: ${service}` };
    }

    log.task.debug('Target config file', { configFile });

    // Create backup if existing config exists and backup is requested
    if (backup_existing) {
      const backupResult = await executeCommand(
        `test -f ${configFile} && pfexec cp ${configFile} ${configFile}.backup.$(date +%Y%m%d_%H%M%S) || echo "No existing config to backup"`
      );
      if (backupResult.success) {
        log.task.debug('Config backup created (if file existed)');
      } else {
        log.task.warn('Failed to create backup', {
          error: backupResult.error,
        });
      }
    }

    // Write new config content
    const writeResult = await executeCommand(
      `echo '${config_content.replace(/'/g, "'\\''")}' | pfexec tee ${configFile}`
    );

    if (!writeResult.success) {
      return {
        success: false,
        error: `Failed to write config file ${configFile}: ${writeResult.error}`,
      };
    }

    log.task.info('Config file written successfully', { configFile });

    // Restart service if requested
    if (restart_service) {
      log.task.debug('Restarting service', { service });
      const restartResult = await executeCommand(`pfexec svcadm restart network/${service}`);

      if (!restartResult.success) {
        return {
          success: true, // Config was written successfully
          message: `Time sync configuration updated successfully, but service restart failed: ${restartResult.error}`,
          warning: `Service ${service} restart failed - may need manual restart`,
        };
      }
      log.task.info('Service restarted successfully', { service });
    }

    return {
      success: true,
      message: `Time sync configuration updated successfully for ${service}${restart_service ? ' (service restarted)' : ''}`,
      config_file: configFile,
    };
  } catch (error) {
    log.task.error('Time sync config update task exception', {
      error: error.message,
      stack: error.stack,
    });
    return { success: false, error: `Time sync config update task failed: ${error.message}` };
  }
};

/**
 * Execute force time synchronization task
 * @param {string} metadataJson - Task metadata as JSON string
 * @returns {Promise<{success: boolean, message?: string, error?: string}>}
 */
export const executeForceTimeSyncTask = async metadataJson => {
  log.task.debug('Force time sync task starting');

  try {
    const metadata = await new Promise((resolve, reject) => {
      yj.parseAsync(metadataJson, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
    const { service, server, timeout } = metadata;

    log.task.debug('Force time sync parameters', {
      service,
      server: server || 'auto-detect',
      timeout,
    });

    let syncResult;

    if (service === 'ntp') {
      // For NTP, use ntpdig for immediate sync
      let command = `pfexec ntpdig`;
      if (timeout) {
        command += ` -t ${timeout}`;
      }
      if (server) {
        command += ` ${server}`;
      } else {
        command += ` pool.ntp.org`; // Default fallback server
      }

      log.task.debug('Executing NTP sync command', { command });
      syncResult = await executeCommand(command, (timeout || 30) * 1000);
    } else if (service === 'chrony') {
      // For Chrony, use chronyc to force sync
      log.task.debug('Executing Chrony makestep command');
      syncResult = await executeCommand(`pfexec chronyc makestep`, (timeout || 30) * 1000);

      if (!syncResult.success) {
        // Fallback to burst command
        log.task.debug('Makestep failed, trying burst command');
        syncResult = await executeCommand(`pfexec chronyc burst 5/10`, (timeout || 30) * 1000);
      }
    } else {
      return { success: false, error: `Cannot force sync - unknown service: ${service}` };
    }

    if (syncResult.success) {
      log.task.info('Time sync command completed successfully');

      // Get current system time for confirmation
      const timeResult = await executeCommand('date');
      const currentTime = timeResult.success ? timeResult.output : 'unknown';

      return {
        success: true,
        message: `Time synchronization completed successfully using ${service}${server ? ` (server: ${server})` : ''}`,
        current_time: currentTime,
        sync_output: syncResult.output,
      };
    }
    log.task.error('Time sync command failed', {
      error: syncResult.error,
    });
    return {
      success: false,
      error: `Time synchronization failed: ${syncResult.error}`,
    };
  } catch (error) {
    log.task.error('Force time sync task exception', {
      error: error.message,
      stack: error.stack,
    });
    return { success: false, error: `Force time sync task failed: ${error.message}` };
  }
};

/**
 * Execute timezone setting task
 * @param {string} metadataJson - Task metadata as JSON string
 * @returns {Promise<{success: boolean, message?: string, error?: string}>}
 */
export const executeSetTimezoneTask = async metadataJson => {
  log.task.debug('Set timezone task starting');

  try {
    const metadata = await new Promise((resolve, reject) => {
      yj.parseAsync(metadataJson, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
    const { timezone, backup_existing } = metadata;

    log.task.debug('Set timezone parameters', {
      timezone,
      backup_existing,
    });

    const configFile = '/etc/default/init';

    // Validate timezone exists
    const zonePath = `/usr/share/lib/zoneinfo/${timezone}`;
    const validateResult = await executeCommand(`test -f ${zonePath}`);
    if (!validateResult.success) {
      return {
        success: false,
        error: `Invalid timezone: ${timezone} - timezone file not found at ${zonePath}`,
      };
    }

    log.task.debug('Timezone validated successfully');

    // Create backup if requested
    if (backup_existing) {
      const backupResult = await executeCommand(
        `pfexec cp ${configFile} ${configFile}.backup.$(date +%Y%m%d_%H%M%S)`
      );
      if (backupResult.success) {
        log.task.debug('Config backup created');
      } else {
        log.task.warn('Failed to create backup', {
          error: backupResult.error,
        });
      }
    }

    // Read current config
    const readResult = await executeCommand(`cat ${configFile}`);
    if (!readResult.success) {
      return {
        success: false,
        error: `Failed to read config file ${configFile}: ${readResult.error}`,
      };
    }

    // Update timezone in config
    let configContent = readResult.output;
    const tzPattern = /^TZ=.*$/m;

    if (tzPattern.test(configContent)) {
      // Replace existing TZ line
      configContent = configContent.replace(tzPattern, `TZ=${timezone}`);
      log.task.debug('Updated existing TZ line');
    } else {
      // Add TZ line
      configContent += `\nTZ=${timezone}\n`;
      log.task.debug('Added new TZ line');
    }

    // Write updated config
    const writeResult = await executeCommand(
      `echo '${configContent.replace(/'/g, "'\\''")}' | pfexec tee ${configFile}`
    );

    if (!writeResult.success) {
      return {
        success: false,
        error: `Failed to write config file ${configFile}: ${writeResult.error}`,
      };
    }

    log.task.info('Timezone config written successfully', { configFile });

    // Set reboot required flag
    await setRebootRequired('timezone_change', 'TaskQueue');

    // Verify the change
    const verifyResult = await executeCommand(`grep "^TZ=" ${configFile}`);
    const verifiedTz = verifyResult.success ? verifyResult.output : 'unknown';

    return {
      success: true,
      message: `Timezone set to ${timezone} successfully (reboot required for full effect)`,
      config_file: configFile,
      verified_setting: verifiedTz,
      requires_reboot: true,
      reboot_reason: 'Timezone change in /etc/default/init requires system reboot to take effect',
    };
  } catch (error) {
    log.task.error('Set timezone task exception', {
      error: error.message,
      stack: error.stack,
    });
    return { success: false, error: `Set timezone task failed: ${error.message}` };
  }
};

/**
 * Helper function to migrate servers from current config
 * @param {string} current_system - Current system name
 * @param {Object} systems_info - Systems information
 * @returns {Promise<Array<string>>} Migrated servers
 */
const migrateServersFromCurrentConfig = async (current_system, systems_info) => {
  const defaultServers = ['0.pool.ntp.org', '1.pool.ntp.org', '2.pool.ntp.org', '3.pool.ntp.org'];

  if (current_system === 'none') {
    return defaultServers;
  }

  log.task.debug('Attempting to extract servers from current configuration');
  const currentInfo = systems_info.available[current_system];
  if (currentInfo && currentInfo.config_file) {
    const readConfigResult = await executeCommand(
      `cat ${currentInfo.config_file} 2>/dev/null || echo ""`
    );
    if (readConfigResult.success && readConfigResult.output.trim()) {
      const extractedServers = extractServersFromConfig(readConfigResult.output, current_system);
      if (extractedServers.length > 0) {
        log.task.info('Extracted servers from current config', {
          servers: extractedServers,
        });
        return extractedServers;
      }
    } else {
      log.task.warn('Could not read current config, using defaults');
    }
  }

  return defaultServers;
};

/**
 * Helper function to setup target system
 * @param {string} target_system - Target system name
 * @param {Object} targetInfo - Target system info
 * @param {string} current_system - Current system name
 * @param {boolean} install_if_needed - Whether to install if needed
 * @param {Array<string>} migratedServers - Migrated servers
 * @returns {Promise<{success: boolean, configFile?: string, error?: string}>}
 */
const setupTargetSystem = async (
  target_system,
  targetInfo,
  current_system,
  install_if_needed,
  migratedServers
) => {
  // Step 4: Install target package if needed
  if (!targetInfo.installed && install_if_needed) {
    log.task.info('Installing package', {
      system: target_system,
      package: targetInfo.package_name,
    });
    const installResult = await executeCommand(
      `pfexec pkg install ${targetInfo.package_name}`,
      5 * 60 * 1000
    );
    if (!installResult.success) {
      return {
        success: false,
        error: `Failed to install ${targetInfo.package_name}: ${installResult.error}`,
      };
    }
    log.task.info('Package installed successfully', {
      package: targetInfo.package_name,
    });
  }

  // Step 5: Generate configuration for target system
  log.task.debug('Generating configuration', { system: target_system });
  let configContent;
  try {
    configContent = generateConfigForSystem(target_system, migratedServers);
    log.task.debug('Configuration generated successfully');
  } catch (configError) {
    return {
      success: false,
      error: `Failed to generate configuration: ${configError.message}`,
    };
  }

  // Step 6: Write target configuration
  const configFile = targetInfo.config_file;
  log.task.debug('Writing configuration', { configFile });
  const writeResult = await executeCommand(
    `echo '${configContent.replace(/'/g, "'\\''")}' | pfexec tee ${configFile}`
  );

  if (!writeResult.success) {
    return {
      success: false,
      error: `Failed to write config file ${configFile}: ${writeResult.error}`,
    };
  }
  log.task.info('Configuration written successfully', { configFile });

  return { success: true, configFile };
};

/**
 * Helper function to disable current time sync service
 * @param {string} current_system - Current system name
 * @returns {Promise<void>}
 */
const disableCurrentService = async current_system => {
  if (current_system !== 'none') {
    log.task.debug('Disabling current service', { service: current_system });
    const disableResult = await executeCommand(`pfexec svcadm disable network/${current_system}`);
    if (!disableResult.success) {
      log.task.warn('Failed to disable service', {
        service: current_system,
        error: disableResult.error,
      });
    } else {
      log.task.info('Current service disabled', { service: current_system });
    }
  }
};

/**
 * Helper function to enable and verify target service
 * @param {string} target_system - Target system name
 * @returns {Promise<{success: boolean, serviceOnline: boolean, error?: string}>}
 */
const enableAndVerifyTargetService = async target_system => {
  log.task.debug('Enabling service', { service: target_system });
  const enableResult = await executeCommand(`pfexec svcadm enable network/${target_system}`);

  if (!enableResult.success) {
    return {
      success: false,
      serviceOnline: false,
      error: `Failed to enable ${target_system} service: ${enableResult.error}`,
    };
  }

  log.task.debug('Verifying service status', { service: target_system });
  const serviceOnline = await verifyServiceStatus(target_system, 10);

  if (!serviceOnline) {
    log.task.warn('Service may not be fully online yet', {
      service: target_system,
    });
  }

  return { success: true, serviceOnline };
};

/**
 * Helper function to verify time sync is working
 * @param {string} target_system - Target system name
 * @returns {Promise<boolean>} Sync working status
 */
const verifySyncWorking = async target_system => {
  log.task.debug('Performing basic sync verification');
  let syncWorking = false;

  if (target_system === 'ntp') {
    const ntpqResult = await executeCommand(`ntpq -p`, 10000);
    syncWorking = ntpqResult.success && ntpqResult.output.includes('remote');
  } else if (target_system === 'chrony') {
    const chronycResult = await executeCommand(`chronyc sources`, 10000);
    syncWorking = chronycResult.success && chronycResult.output.includes('Name/IP address');
  }

  return syncWorking;
};

/**
 * Execute time sync system switching task
 * @param {string} metadataJson - Task metadata as JSON string
 * @returns {Promise<{success: boolean, message?: string, error?: string}>}
 */
export const executeSwitchTimeSyncSystemTask = async metadataJson => {
  log.task.debug('Time sync system switch task starting');

  try {
    const metadata = await new Promise((resolve, reject) => {
      yj.parseAsync(metadataJson, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
    const { current_system, target_system, preserve_servers, install_if_needed, systems_info } =
      metadata;

    log.task.debug('Time sync system switch parameters', {
      current_system,
      target_system,
      preserve_servers,
      install_if_needed,
    });

    // Step 1: Extract servers from current config if requested
    let migratedServers;
    if (preserve_servers) {
      migratedServers = await migrateServersFromCurrentConfig(current_system, systems_info);
    } else {
      migratedServers = ['0.pool.ntp.org', '1.pool.ntp.org', '2.pool.ntp.org', '3.pool.ntp.org'];
    }

    // Step 2: Disable current service if active
    await disableCurrentService(current_system);

    // Step 3: Handle target system installation and configuration
    if (target_system === 'none') {
      log.task.debug('Target is "none" - time sync will be disabled');
      return {
        success: true,
        message: `Switched from ${current_system} to none (time sync disabled)`,
        current_system: 'none',
        original_system: current_system,
      };
    }

    const targetInfo = systems_info.available[target_system];
    if (!targetInfo) {
      return { success: false, error: `Unknown target system: ${target_system}` };
    }

    // Setup target system
    const setupResult = await setupTargetSystem(
      target_system,
      targetInfo,
      current_system,
      install_if_needed,
      migratedServers
    );
    if (!setupResult.success) {
      // Rollback: re-enable original service
      if (current_system !== 'none') {
        log.task.warn('Setup failed, rolling back', {
          target: target_system,
          rollback_to: current_system,
          error: setupResult.error,
        });
        await executeCommand(`pfexec svcadm enable network/${current_system}`);
      }
      return {
        success: false,
        error: setupResult.error,
        rollback_performed: current_system !== 'none',
      };
    }

    // Step 7: Enable and verify target service
    const verifyResult = await enableAndVerifyTargetService(target_system);
    if (!verifyResult.success) {
      // Rollback: re-enable original service
      if (current_system !== 'none') {
        log.task.warn('Service enable failed, rolling back', {
          target: target_system,
          rollback_to: current_system,
          error: verifyResult.error,
        });
        await executeCommand(`pfexec svcadm enable network/${current_system}`);
      }
      return {
        success: false,
        error: verifyResult.error,
        rollback_performed: current_system !== 'none',
      };
    }

    // Step 8: Verify time sync is working
    const syncWorking = await verifySyncWorking(target_system);

    const finalMessage = `Successfully switched from ${current_system} to ${target_system}`;
    const result = {
      success: true,
      message: finalMessage,
      current_system: target_system,
      original_system: current_system,
      servers_migrated: preserve_servers,
      migrated_servers: migratedServers,
      config_file: setupResult.configFile,
      service_online: verifyResult.serviceOnline,
      sync_verification: syncWorking ? 'working' : 'unknown',
    };

    if (preserve_servers) {
      result.message += ` (${migratedServers.length} servers migrated)`;
    }

    if (!verifyResult.serviceOnline) {
      result.message += ' (service may need additional time to fully start)';
    }

    log.task.info('Time sync system switch completed', {
      from: current_system,
      to: target_system,
      servers_migrated: preserve_servers,
      service_online: verifyResult.serviceOnline,
      sync_working: syncWorking,
    });
    return result;
  } catch (error) {
    log.task.error('Time sync system switch task exception', {
      error: error.message,
      stack: error.stack,
    });
    return { success: false, error: `Time sync system switch failed: ${error.message}` };
  }
};
